## 正规式
正规式是表达正规语言的工具。每个正规式等价于一个正规集，表示其匹配在正规集内的所有字符串。
![[Pasted image 20220623130725.png]]

## 自动机
自动机可以想象为一个有状态的机器，可以表示为一个状态转换图。这个机器每当输入一个字符，就会从一个状态转换到另一个状态。如果输入的字符不合法，则其就会转移到非法的状态。透过这个机制，便可以对一个字符串做匹配，以及描述一个语言。

![[Pasted image 20220623131313.png]]

## DFA （确定有限状态自动机）
确定指的是这类自动机的初始态是唯一的，而有限则代表其必须是可以在有限步数终止的。
直观的DFA，只要描述其匹配的转换步骤就足够了，但是严格意义上的DFA，每个状态都需要有对应的边去处理可能的输入，并把非法的输入导到一个无线循环的死状态。

## NFA (非确定有限状态自动机)
同理，NFA和DFA主要的区别就在于有没有确定的初始状态，在状态转换图上的体现，便是NFA允许出现空匹配的边（所以实际上也只有一个起点，但是透过空边可以跳到多个初始态而不匹配任何字符）。
尽管如此，NFA和DFA实际上是等价的，NFA的用途主要在于可以更为简单直观的构造。

## 最简问题
![[Pasted image 20220623135239.png]]

一个文法可以有数个表达方式，无论是RE，NFA,DFA都不是唯一的。如此一来，这就给等价性的判断带来了困难。而实际上，透过算法我们可以将他们都化为最简DFA，从而判断其等价性。

### Thompson 算法 （RE -> NFA ）
1. 将每一个字符的匹配转换为一个起始态，一个边，一个终结态的自动机
2. 透过 `|` 或是 `+` 链接的字符，将其各自的初始态通过空边连接到一个新的初始态。
3. 对于在`(x)*`内的`x`对于的自动机，通过空边将其终结态与初始态相联。

### 子集构造法 (NFA -> DFA)
子集构造法的核心精神便是*寻找等价类*。等价类是一个离散数学内的概念，指的是透过某个关系，将在这个关系上等价的元素统一起来的一个集合。
子集构造法个过程便是透过寻找等价类来构造一个等同于DFA的表格。

在表格中，I代表的是空边，而I(`x`)代表的是匹配`x`的边。表格最一开始从最左上开始，填入从初始态经过空边可达的所有状态所构成的子集（包含初始态），接着重复以下步骤：

1. 于当前行遍历所有I(`x`)列，在对应行列的格子内填入当前行的最左等价类，经过匹配`x`可达的所有状态所构成的子集。
2. 将第1步得到的每个子集填入最左的后续行，并从下一行开始重复步骤1。

完成以上步骤后，实际上DFA就已经确定了，只要再做两步进行转换：

1. 将相同的子集命名为同一个状态`x`。
2. 依序将每个状态画出，并将对应的边连上。 

![[Pasted image 20220623150251.png]]

### Hopcroft 算法 （化简DFA)
Hopcroft算法的核心精神也是寻找等价类，但是等价类的判断在于，一个等价类内所有的状态，在经过匹配`x`的边后，都会抵达相同的等价类。在Hocroft算法需要注意死状态，所有状态如果没有合法的边去匹配字符，那么都视做存在一个匹配的边通向一个共同的死状态。
将等价类归于新的状态，并继承所有边，就得到了最简的DFA。

![[Pasted image 20220623153122.png]]